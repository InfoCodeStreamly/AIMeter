name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    name: Build, Sign, Notarize and Release
    runs-on: macos-15
    timeout-minutes: 30
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version script

      - name: Select Xcode
        run: |
          # Use latest available Xcode on the runner
          sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

      - name: Show Build Environment
        run: |
          xcodebuild -version
          swift --version
          echo "macOS: $(sw_vers -productVersion)"
          echo "Tag: ${{ github.ref_name }}"

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.DEVELOPER_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(uuidgen)

          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "Importing code signing certificate..."
          echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign

          # Allow codesign to access keychain without prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Set as default keychain
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm -f certificate.p12

          # Find the imported identity
          echo "Finding imported Developer ID certificate..."
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed -E 's/.*"(.+)"/\1/')

          if [ -z "$IDENTITY" ]; then
            echo "Error: Developer ID Application certificate not found"
            security find-identity -v -p codesigning "$KEYCHAIN_PATH"
            exit 1
          fi

          echo "Found identity: $IDENTITY"
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV

          echo "Code signing certificate imported successfully"

      - name: Build Release
        run: |
          echo "Building release (version from git tag via build script)..."

          xcodebuild build \
            -project AIMeter.xcodeproj \
            -scheme AIMeter \
            -configuration Release \
            -derivedDataPath build \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

          echo "Build completed successfully"

      - name: Sign App Bundle
        run: |
          APP_PATH="build/Build/Products/Release/AIMeter.app"
          SPARKLE_PATH="$APP_PATH/Contents/Frameworks/Sparkle.framework"

          echo "=== Signing Sparkle framework components ==="

          # Find and sign all Mach-O executables in Sparkle (including Autoupdate)
          echo "Signing Sparkle executables..."
          find "$SPARKLE_PATH" -type f -perm +111 | while read binary; do
            # Check if it's a Mach-O binary
            if file "$binary" | grep -q "Mach-O"; then
              echo "Signing binary: $binary"
              codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime "$binary"
            fi
          done

          # Sign XPC services
          echo "Signing XPC services..."
          find "$SPARKLE_PATH" -name "*.xpc" -type d | while read xpc; do
            echo "Signing: $xpc"
            codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime "$xpc"
          done

          # Sign helper apps
          echo "Signing helper apps..."
          find "$SPARKLE_PATH" -name "*.app" -type d | while read app; do
            echo "Signing: $app"
            codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime "$app"
          done

          # Sign Sparkle framework itself
          echo "Signing Sparkle.framework..."
          codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime "$SPARKLE_PATH"

          # Verify Sparkle signing
          echo "Verifying Sparkle signature..."
          codesign --verify --deep --verbose=2 "$SPARKLE_PATH" || echo "Warning: Sparkle verification issues (may be expected for SPM)"

          echo "=== Signing main app bundle ==="
          echo "Signing with: $SIGNING_IDENTITY"
          codesign --force --sign "$SIGNING_IDENTITY" \
            --timestamp \
            --options runtime \
            --entitlements "AIMeter/AIMeterRelease.entitlements" \
            "$APP_PATH"

          echo "App bundle signed successfully"

      - name: Verify Code Signature
        run: |
          APP_PATH="build/Build/Products/Release/AIMeter.app"

          echo "Verifying code signature..."
          codesign --verify --deep --verbose=2 "$APP_PATH"

          echo ""
          echo "Code signature details:"
          codesign -dv --verbose=2 "$APP_PATH" 2>&1

          echo "Code signature verified successfully"

      - name: Notarize App
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
        run: |
          APP_PATH="build/Build/Products/Release/AIMeter.app"

          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent "$APP_PATH" "notarization.zip"

          echo "Submitting app for notarization..."
          echo "This may take 5-15 minutes..."

          # Submit and capture output
          SUBMIT_OUTPUT=$(xcrun notarytool submit "notarization.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$TEAM_ID" \
            --wait \
            --timeout 30m 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Check if notarization was successful
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
            echo ""
            echo "Notarization successful! Stapling ticket to app..."
            xcrun stapler staple "$APP_PATH"

            echo ""
            echo "Verifying stapled notarization ticket..."
            xcrun stapler validate "$APP_PATH"

            rm -f notarization.zip
            echo "App notarized and stapled successfully"
          else
            echo ""
            echo "Notarization FAILED. Fetching detailed log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_ID_PASSWORD" \
              --team-id "$TEAM_ID"

            rm -f notarization.zip
            exit 1
          fi

      - name: Install create-dmg
        run: brew install create-dmg

      - name: Create DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          APP_PATH="build/Build/Products/Release/AIMeter.app"

          mkdir -p release

          echo "Creating DMG..."
          create-dmg \
            --volname "AIMeter" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "AIMeter.app" 150 190 \
            --hide-extension "AIMeter.app" \
            --app-drop-link 450 185 \
            --no-internet-enable \
            "release/AIMeter-${VERSION}.dmg" \
            "$APP_PATH" || true

          # Check if DMG was created
          if [ ! -f "release/AIMeter-${VERSION}.dmg" ]; then
            echo "Error: DMG creation failed"
            exit 1
          fi

          echo "DMG created, submitting for notarization..."
          xcrun notarytool submit "release/AIMeter-${VERSION}.dmg" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$TEAM_ID" \
            --wait

          echo "Stapling notarization ticket to DMG..."
          xcrun stapler staple "release/AIMeter-${VERSION}.dmg"

          # Generate checksum
          echo "Generating SHA256 checksum..."
          shasum -a 256 "release/AIMeter-${VERSION}.dmg" > "release/AIMeter-${VERSION}.dmg.sha256"

          echo ""
          echo "SHA256 Checksum:"
          cat "release/AIMeter-${VERSION}.dmg.sha256"

          echo "DMG created and notarized successfully"

      - name: Sign Update with Sparkle EdDSA
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          DMG_PATH="release/AIMeter-${VERSION}.dmg"

          # Download Sparkle tools
          echo "Downloading Sparkle tools..."
          curl -L -o /tmp/sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz
          mkdir -p /tmp/sparkle
          tar -xf /tmp/sparkle.tar.xz -C /tmp/sparkle

          # Sign with EdDSA private key
          echo "Signing DMG with Sparkle EdDSA..."
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_key.txt
          FULL_OUTPUT=$(/tmp/sparkle/bin/sign_update "$DMG_PATH" -f /tmp/sparkle_key.txt)
          rm /tmp/sparkle_key.txt

          # Extract just the signature value (sign_update outputs: sparkle:edSignature="XXX" length="YYY")
          SIGNATURE=$(echo "$FULL_OUTPUT" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')

          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "Sparkle EdDSA signature: $SIGNATURE"

      - name: Generate appcast.xml
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          DMG_PATH="release/AIMeter-${VERSION}.dmg"
          FILE_SIZE=$(stat -f%z "$DMG_PATH")
          PUB_DATE=$(date -R)

          printf '%s\n' '<?xml version="1.0" encoding="utf-8"?>' > release/appcast.xml
          printf '%s\n' '<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">' >> release/appcast.xml
          printf '%s\n' '  <channel>' >> release/appcast.xml
          printf '%s\n' '    <title>AIMeter Updates</title>' >> release/appcast.xml
          printf '%s\n' '    <link>https://github.com/InfoCodeStreamly/AIMeter/releases</link>' >> release/appcast.xml
          printf '%s\n' '    <description>Most recent updates to AIMeter</description>' >> release/appcast.xml
          printf '%s\n' '    <language>en</language>' >> release/appcast.xml
          printf '%s\n' '    <item>' >> release/appcast.xml
          printf '%s\n' "      <title>Version ${VERSION}</title>" >> release/appcast.xml
          printf '%s\n' "      <pubDate>${PUB_DATE}</pubDate>" >> release/appcast.xml
          printf '%s\n' "      <sparkle:version>${VERSION}</sparkle:version>" >> release/appcast.xml
          printf '%s\n' "      <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>" >> release/appcast.xml
          printf '%s\n' '      <sparkle:minimumSystemVersion>15.0</sparkle:minimumSystemVersion>' >> release/appcast.xml
          printf '%s\n' "      <enclosure url=\"https://github.com/InfoCodeStreamly/AIMeter/releases/download/v${VERSION}/AIMeter-${VERSION}.dmg\" length=\"${FILE_SIZE}\" type=\"application/octet-stream\" sparkle:edSignature=\"${SPARKLE_SIGNATURE}\" />" >> release/appcast.xml
          printf '%s\n' '    </item>' >> release/appcast.xml
          printf '%s\n' '  </channel>' >> release/appcast.xml
          printf '%s\n' '</rss>' >> release/appcast.xml

          echo "Generated appcast.xml:"
          cat release/appcast.xml

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: AIMeter ${{ github.ref_name }}
          draft: false
          generate_release_notes: true
          files: |
            release/AIMeter-*.dmg
            release/AIMeter-*.dmg.sha256
            release/appcast.xml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  Release ${{ github.ref_name }} published!"
          echo "=========================================="
          echo ""
          echo "  - Signed with Developer ID Application"
          echo "  - Notarized by Apple"
          echo "  - DMG with drag-to-Applications"
          echo "  - Sparkle EdDSA signed for auto-updates"
          echo "  - appcast.xml generated"
          echo "  - Published to GitHub Releases"
          echo ""
